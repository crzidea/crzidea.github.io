title: 用正确的姿势在分布式的构建环境中优化-nodejs-项目部署速度
date: 2016-03-29 11:58:44
tags: node build deploy distribution
---

拆解一下标题：

* 优化nodejs项目部署速度
* 在分布式的构建环境中
* 用正确的姿势

## 三个阶段

Deploy At  | Time Spend
---------- | ----------
2015-12-10 | 6s
2016-03-11 | 240s
2016-03-28 | 53s

### 第一阶段：单机构建、单机上线

![](/img/20160329/20160329.001.jpeg)

这是我们最早的部署流程。线上只有一台机器，我们可以登录这台机器，然后手动的安装一些通用依赖（比如node、npm、nginx），**甚至是项目的package.json中的依赖**，就已经可以跑起来了。

但是这个部署流程的问题非常严重（已在上图标出）：

* **没有扩展性可言。**一旦要加机器，必须登录新机器，手动把依赖装一遍。加一台两台还好，加个5、6台，挨个机器登录装依赖烦死你。尤其是在我们这种有事没事儿给你搞个机房下线、域名乱改的生存环境中，到之后对接运维工作的人只能呵呵啊！
* **依赖更新不及时。**原则上，我们的依赖应该要与社区的stable按本对齐的。可是有几个团队保持这种原则？原因略过。就算是你不想更新，那天社区爆出了一个安全漏洞，你也不得不去更新。到之后怎么办？再挨个机器登录更新依赖？到时候一样只能呵呵啊！

这一阶段，部署一次，大概花费6秒左右。


### 第二阶段：多机构建、多机上线

![](/img/20160329/20160329.002.jpeg)

后来我把发布的流程改成了这个样子（**标黄的内容是做的修改**）。抹平了上一个阶段的坑（然后又砸出了几个坑）。

把安装依赖的过程放到构建机来做，这样做：

* 不需要跑到每个机器上安装依赖。因为安装依赖已经在重启服务的脚本里了。
* 保证了每次上线的时候，依赖都是和社区的stable版本对齐的。

但是又出现了新的问题：

* **构建机安装依赖的时间非常长。**我们每次点击了“我要部署”的按钮之后，都要等构建机器安装好了最新的依赖（2-5分钟），才能进入发布文件的流程。
* 多个项目的构建脚本和重启脚本维护起来比较困难。但是这些脚本的内容很多是重复的。比如几乎所有项目的pre-deploy.sh的脚本内容都是一样的，再比如每个脚本基本上都要检查nvm、node的版本并执行npm install。

这一阶段，部署一次，大概花费240秒左右。

### 第三阶段：优化后

这一阶段是我们要探讨的主要问题是，我们不能接受上线一次需要花费240秒（有时甚至是300秒）。

那我们该怎么做呢？

## 找出“岁月神偷”

```
[2016-03-11 15:25:44] => npm install
...
[2016-03-11 15:28:52] => bower install
```

以上是从部署入职里摘出来的一部分。真的留意的是“...”上下的时间，一共花费了188秒。

npm install 的确很慢，但是每次都慢吗？

其实npm发现当前项目目录中已经有node_modules目录的时候，是会检查（虽然检查的很慢）那些依赖已经被安装过了的。

```
$ time npm install
...
 
real    0m11.685s
user    0m11.411s
sys     0m1.110s
```

这就说明其实构建机并没有保存我们上一次的构建结果，每次部署结束之后，构建结果都会被自动清理掉。

之后我又向维护OPS的同学求证了一下，构建结果其实有保存，是保存在了云存储上。但是并没有给我们开放获取构建结果的途径。

```
[2016-03-28 11:44:32] Upload build/mit.blog/mit.blog-2016-03-28-11-43-56.tar.gz ...
[2016-03-28 11:44:37] Upload build/mit.blog/mit.blog-2016-03-28-11-43-56.tar.gz success!
```

~~（丫的，不让我们用还占用了我们5s的时间。5s，5s我都可以上天了！）~~

总结一下我们在构建这件事情上遇到的问题：

* 构建机器是分布式的。会从一个集群中随机抽取一台来处理我们的构建请求。
* 构建机器上的构建结果会被保存，但是我们无法获取。
* 即使我们使用了缓存的构建结果，npm检查的速度依然很慢。

## 抄近道

超车哪有不粗暴的？针对上面遇到的问题，我就是要用粗暴的方式搞定。


### 近道一：自建服务器缓存构建结果

![](/img/20160329/20160329.003.jpeg)

核心思路是把构建结果缓存起来，实现188s（无node_modules） => 11s （有node_modules）的依赖安装过程优化。

### 近道二：使用更粗暴的方式比对项目依赖是否需要更新

![](/img/20160329/20160329.004.jpeg)

这就更暴力了，直接把现在的package.json和之前有构建结果的package.json进行文本比对，再最理想的情况下，可以直接干掉npm检查本地node_modules的时间，实现11s（使用npm install检查） => 0s（使用diff检查）的依赖安装过程的优化。

（上图中，实现表示理想情况，虚线表示需要重新安装依赖的情况。）

## 部署速度不是全部的财富

需要注意的是，我们优化之后仍然不会恢复到之前5s上线的速度，因为我们做了一系列的严格环境检查：

* 对构建环境的node版本做了检查。
* 对线上环境的node版本做了检查。
* 线上机器是分布式的环境，会对服务进行轮流重启。每重启一批机器，大概需要花费7秒。一般情况下，不管服务器有几台，都会分两批重启（保持一批持续提供服务），所以一般会花费14秒在重启服务商。
* OPS把构建结果上传到了云存储。不受我们控制，每次消耗5秒（还不给我们用）。
* 除上述之外，OPS准备时间花费了14秒。

这样算下来，到现在为止，我们自己在构建上花费的时间真的就只有不到20（53-14-5-14）秒了，未来我们会干掉bower，还会再减7秒。而且建立了非常稳健的环境检查机制，这比单纯追求速度更有价值。

```
[2016-03-28 11:44:12] [localhost] local: /bin/bash -l -c "./bin/pre-deploy.sh"
...
[2016-03-28 11:44:13] Downloading http://npm.sankuai.com/dist/node/v5.9.1/node-v5.9.1-linux-x64.tar.xz...
...
[2016-03-28 11:44:13] WARNING: checksums are currently disabled for node.js v4.0 and later
[2016-03-28 11:44:16] Now using node v5.9.1 (npm v3.7.3)
...
[2016-03-28 11:44:21] modules are loaded fram sankuai@10.4.232.99:~/.tmp/mtblog/
```

> 对构建环境的node版本做了检查
 
```
[2016-03-28 11:44:40] [server1] run: ./bin/post-deploy.sh
...
[2016-03-28 11:44:44] [server1] out: [PM2] Done.
```

> 每重启一批机器，大概需要花费9秒。
 
```
[2016-03-11 15:28:52] => bower install
[2016-03-11 15:28:59] bower breakpoint-sass#~2.6.1 ENOTFOUND Request to https://bower.herokuapp.com/packages/breakpoint-sass failed: getaddrinfo ENOTFOUND
```

> 未来我们会干掉bower，还会再减7秒。